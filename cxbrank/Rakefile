$LOAD_PATH << '../comrank/lib'

require 'yaml'
require 'csv'
require 'rubygems'
require 'active_record'
require 'sinatra/activerecord'
require 'sinatra/activerecord/rake'
require 'cxbrank/const'
require 'cxbrank/music'
require 'cxbrank/event'

def quote(value)
  if value.nil?
    return 'null'
  elsif value.is_a?(String)
    return "'#{value.gsub(/'/, "''")}'"
  elsif value.is_a?(Date)
    return "'#{value.strftime('%Y-%m-%d')}'"
  elsif value.is_a?(Time)
    return "'#{value.strftime('%Y-%m-%d %H:%M:%S')}'"
  else
    return value.to_s
  end
end

ActiveRecord::Base.configurations = YAML.load_file(CxbRank::DATABASE_FILE)
ActiveRecord::Base.establish_connection(YAML.load_file(CxbRank::CONFIG_FILE)['environment'])

namespace :cxbrank do
  desc 'initialize music master'
  task :init_master do
    CSV.open('./db/master/musics.tsv', 'r', "\t") do |row|
      music = CxbRank::Music.find(:first, :conditions => {:lookup_key => row[0]})
      unless music
        music = CxbRank::Music.new
        music.lookup_key = row[0]
      end
      music.text_id = row[0]
      music.number = row[1]
      music.title = row[2]
      music.subtitle = row[3]
      music.sort_key = row[4]
      music.esy_level = row[5]
      music.esy_notes = row[6]
      music.std_level = row[7]
      music.std_notes = row[8]
      music.hrd_level = row[9]
      music.hrd_notes = row[10]
      music.mas_level = row[11]
      music.mas_notes = row[12]
      music.unl_level = row[13]
      music.unl_notes = row[14]
      music.limited = row[15] if row[15].present?
      music.hidden = row[16] if row[16].present?
      music.display = row[17] if row[17].present?
      music.added_at = row[18] if row[18].present?
      music.event = row[19]
      music.save!
    end

    CSV.open('./db/master/monthlies.tsv', 'r', "\t") do |row|
      music_id = CxbRank::Music.find(:first, :conditions => {:text_id => row[0]}).id
      monthly = CxbRank::Monthly.find(:first, :conditions => {:music_id => music_id, :span_s => row[1]})
      unless monthly
        monthly = CxbRank::Monthly.new
        monthly.music_id = music_id
        monthly.span_s = row[1]
      end
      monthly.span_e = row[2]
      monthly.save!
    end

    CSV.open('./db/master/legacy_charts.tsv', 'r', "\t") do |row|
      music_id = CxbRank::Music.find(:first, :conditions => {:text_id => row[0]}).id
      chart = CxbRank::LegacyChart.find(:first, :conditions => {:music_id => music_id, :span_s => row[1]})
      unless chart
        chart = CxbRank::LegacyChart.new
        chart.music_id = music_id
        chart.span_s = row[1]
      end
      chart.span_e = row[2]
      chart.esy_level = row[3]
      chart.esy_notes = row[4]
      chart.std_level = row[5]
      chart.std_notes = row[6]
      chart.hrd_level = row[7]
      chart.hrd_notes = row[8]
      chart.mas_level = row[9]
      chart.mas_notes = row[10]
      chart.unl_level = row[11]
      chart.unl_notes = row[12]
      chart.save!
    end

    CSV.open('./db/master/events.tsv', 'r', "\t") do |row|
      event = CxbRank::Event.find(:first, :conditions => {:text_id => row[0], :section => row[1]})
      unless event
        event = CxbRank::Event.new
        event.text_id = row[0]
        event.section = row[1]
      end
      event.title = row[2]
      event.span_s = row[3]
      event.span_e = row[4]
      event.save!
    end

    CSV.open('./db/master/event_musics.tsv', 'r', "\t") do |row|
      event_id = CxbRank::Event.find(:first, :conditions => {:text_id => row[0], :section => row[1]}).id
      event_music = CxbRank::EventMusic.find(:first, :conditions => {:event_id => event_id, :seq => row[2]})
      unless event_music
        event_music = CxbRank::EventMusic.new
        event_music.event_id = event_id
        event_music.seq = row[2]
      end
      music_id = CxbRank::Music.find(:first, :conditions => {:text_id => row[3]}).id
      event_music.music_id = music_id
      event_music.save!
    end
  end

  desc 'make upsert sql'
  task :make_upsert_sql do
    output = File.open('upsert.sql', 'w')
    output.puts '-- musics'
    CSV.open('./db/master/musics.tsv', 'r', "\t") do |row|
      music = CxbRank::Music.new
      music.lookup_key = row[0]
      music.text_id = row[0]
      music.number = row[1]
      music.title = row[2]
      music.subtitle = row[3]
      music.sort_key = row[4]
      music.esy_level = row[5]
      music.esy_notes = row[6]
      music.std_level = row[7]
      music.std_notes = row[8]
      music.hrd_level = row[9]
      music.hrd_notes = row[10]
      music.mas_level = row[11]
      music.mas_notes = row[12]
      music.unl_level = row[13]
      music.unl_notes = row[14]
      music.limited = row[15] if row[15].present?
      music.hidden = row[16] if row[16].present?
      music.display = row[17] if row[17].present?
      music.added_at = row[18] if row[18].present?
      music.event = row[19]
      sql = <<EOS
        insert into musics (lookup_key, text_id, number,
          title, subtitle, sort_key,
          esy_level, esy_notes, std_level, std_notes, hrd_level, hrd_notes,
          mas_level, mas_notes, unl_level, unl_notes,
          limited, hidden, display, added_at, event, created_at, updated_at)
        values (#{quote(music.lookup_key)}, #{quote(music.text_id)}, #{quote(music.number)},
          #{quote(music.title)}, #{quote(music.subtitle)}, #{quote(music.sort_key)},
          #{quote(music.esy_level)}, #{quote(music.esy_notes)},
          #{quote(music.std_level)}, #{quote(music.std_notes)},
          #{quote(music.hrd_level)}, #{quote(music.hrd_notes)},
          #{quote(music.mas_level)}, #{quote(music.mas_notes)},
          #{quote(music.unl_level)}, #{quote(music.unl_notes)},
          #{quote(music.limited)}, #{quote(music.hidden)}, #{quote(music.display)},
          #{quote(music.added_at)}, #{quote(music.event)}, now(), now())
        on duplicate key update
          text_id = #{quote(music.text_id)},
          title = #{quote(music.title)}, subtitle = #{quote(music.subtitle)},
          sort_key = #{quote(music.sort_key)},
          esy_level = #{quote(music.esy_level)}, esy_notes = #{quote(music.esy_notes)},
          std_level = #{quote(music.std_level)}, std_notes = #{quote(music.std_notes)},
          hrd_level = #{quote(music.hrd_level)}, hrd_notes = #{quote(music.hrd_notes)},
          mas_level = #{quote(music.mas_level)}, mas_notes = #{quote(music.mas_notes)},
          unl_level = #{quote(music.unl_level)}, unl_notes = #{quote(music.unl_notes)},
          limited = #{quote(music.limited)}, hidden = #{quote(music.hidden)}, display = #{quote(music.display)},
          added_at = #{quote(music.added_at)}, event = #{quote(music.event)}, updated_at = now();
EOS
      output.puts sql
    end

    output.puts '-- monthlies'
    CSV.open('./db/master/monthlies.tsv', 'r', "\t") do |row|
      text_id = row[0]
      monthly = CxbRank::Monthly.new
      monthly.span_s = row[1]
      monthly.span_e = row[2]
      sql = <<EOS
        insert into monthlies (music_id, span_s, span_e, created_at, updated_at)
        values (
          (select id from musics where text_id = #{quote(text_id)}),
          #{quote(monthly.span_s)}, #{quote(monthly.span_e)}, now(), now())
        on duplicate key update
          span_e = #{quote(monthly.span_e)}, updated_at = now();
EOS
      output.puts sql
    end

    output.puts '-- legacy_charts'
    CSV.open('./db/master/legacy_charts.tsv', 'r', "\t") do |row|
      text_id = row[0]
      chart = CxbRank::LegacyChart.new
      chart.span_s = row[1]
      chart.span_e = row[2]
      chart.esy_level = row[3]
      chart.esy_notes = row[4]
      chart.std_level = row[5]
      chart.std_notes = row[6]
      chart.hrd_level = row[7]
      chart.hrd_notes = row[8]
      chart.mas_level = row[9]
      chart.mas_notes = row[10]
      chart.unl_level = row[11]
      chart.unl_notes = row[12]
      sql = <<EOS
        insert into legacy_charts (music_id, span_s, span_e,
          esy_level, esy_notes, std_level, std_notes, hrd_level, hrd_notes,
          mas_level, mas_notes, unl_level, unl_notes,
          created_at, updated_at)
        values (
          (select id from musics where text_id = #{quote(text_id)}),
          #{quote(chart.span_s)}, #{quote(chart.span_e)},
          #{quote(chart.esy_level)}, #{quote(chart.esy_notes)},
          #{quote(chart.std_level)}, #{quote(chart.std_notes)},
          #{quote(chart.hrd_level)}, #{quote(chart.hrd_notes)},
          #{quote(chart.mas_level)}, #{quote(chart.mas_notes)},
          #{quote(chart.unl_level)}, #{quote(chart.unl_notes)}, now(), now())
        on duplicate key update
          span_e = #{quote(chart.span_e)},
          esy_level = #{quote(chart.esy_level)}, esy_notes = #{quote(chart.esy_notes)},
          std_level = #{quote(chart.std_level)}, std_notes = #{quote(chart.std_notes)},
          hrd_level = #{quote(chart.hrd_level)}, hrd_notes = #{quote(chart.hrd_notes)},
          mas_level = #{quote(chart.mas_level)}, mas_notes = #{quote(chart.mas_notes)},
          unl_level = #{quote(chart.unl_level)}, unl_notes = #{quote(chart.unl_notes)},
          updated_at = now();
EOS
      output.puts sql
    end
    output.close
  end
end
